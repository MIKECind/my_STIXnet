A disk is either a boot disk that is used to start and run the operating system on a virtual machine (VM) instance or a non-boot disk that a VM uses only for data storage. You can use snapshots to backup and restore disk data in the following ways: After you take a snapshot of a boot or non-boot disk, create a new disk based on the snapshot. After you take a snapshot of a boot disk, create a new VM based on the boot disk snapshot. After you take a snapshot of a non-boot disk, create a new VM with a new non-boot disk based on the snapshot. Before you begin - If you want to use the command-line examples in this guide, do the following: - Install or update to the latest version of the Google Cloud CLI. - Set a default region and zone. - If you want to use the API examples in this guide, set up API access. Create a disk from a snapshot and optionally attach it to a VM If you backed up a boot or non-boot disk with a snapshot, you can create a new disk based on the snapshot. Restrictions The new disk must be at least the same size as the original source disk for the snapshot. If you create a disk that is larger than the original source disk for the snapshot, you must resize the file system on that persistent disk to include the additional disk space. Depending on your operating system and file system type, you might need to use a different file system resizing tool. For more information, see your operating system documentation. You can create a new zonal or regional disk from a given snapshot at most once every ten minutes. If you want to issue a burst of requests to snapshot your disks, you can issue at most 6 requests in 60 minutes. This limit does not apply when creating regional disks from a snapshot. For more information, see Snapshot frequency limits. Permissions required for this task To perform this task, you must have the following permissions: compute.disks.createon the project to create a new disk compute.instances.attachDiskon the VM instance compute.disks.usepermission on the disk to attach Console In the Google Cloud console, go to the Snapshots page. Find the name of the snapshot that you want to restore. Go to the Disks page. Click Create new disk. Specify the following configuration parameters: - A name for the disk. - A type for the disk. - Optionally, you can override the default region and zone selection. You can select any region and zone, regardless of the storage location of the source snapshot. Under Source type, click Snapshot. Select the name of the snapshot to restore. Select the size of the new disk, in gigabytes. This number must be equal to or larger than the original source disk for the snapshot. Click Create to create the disk. Optionally, you can then attach the new disk to an existing instance. - Go to the VM instances page. - Click the name of the instance where you want to restore your non-boot disk. - At the top of the instance details page, click Edit. - Under Additional disks, click Attach existing disk. - Select the name of the new disk made from your snapshot. - Click Done to attach the disk. - At the bottom of the instance details page, click Save to apply your changes to the instance. gcloud Use the gcloud compute snapshots listcommand to find the name of the snapshot you want to restore: gcloud compute snapshots list Use the gcloud compute snapshots describecommand to find the size of the snapshot you want to restore: gcloud compute snapshots describe SNAPSHOT_NAME Replace SNAPSHOT_NAME with the name of the snapshot being restored. Use the gcloud compute disks createcommand to create a new regional or zonal disk from your snapshot. If you need an SSD persistent disk for additional throughput or IOPS, include the --typeflag and specify pd-ssd. gcloud compute disks create DISK_NAME \ --size=DISK_SIZE \ --source-snapshot=SNAPSHOT_NAME \ --type=DISK_TYPE Replace the following: - DISK_NAME: the name of the new disk. - DISK_SIZE: The size of the new disk, in gigabytes. This number must be equal to or larger than the original source disk for the snapshot. - SNAPSHOT_NAME: the name of the snapshot being restored. - DISK_TYPE: full or partial URL for the type of the disk. For example, https://www.googleapis.com/compute/v1/projects/PROJECT_ID /zones/ZONE/diskTypes/pd-ssd. Optional: attach the new disk to an existing instance by using the gcloud compute instances attach-diskcommand: gcloud compute instances attach-disk INSTANCE_NAME \ --disk DISK_NAME Replace the following: - INSTANCE_NAME is the name of the instance. - DISK_NAME is the name of the disk made from your snapshot. Go Go Before trying this sample, follow the Go setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Go API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. import ( "context" "fmt" "io" compute "cloud.google.com/go/compute/apiv1" computepb "google.golang.org/genproto/googleapis/cloud/compute/v1" "google.golang.org/protobuf/proto" ) // createDiskFromSnapshot creates a new disk in a project in given zone. func createDiskFromSnapshot( w io.Writer, projectID, zone, diskName, diskType, snapshotLink string, diskSizeGb int64, ) error { // projectID := "your_project_id" // zone := "us-west3-b" // should match diskType below // diskName := "your_disk_name" // diskType := "zones/us-west3-b/diskTypes/pd-ssd" // snapshotLink := "projects/your_project_id/global/snapshots/snapshot_name" // diskSizeGb := 120 ctx := context.Background() disksClient, err := compute.NewDisksRESTClient(ctx) if err != nil { return fmt.Errorf("NewDisksRESTClient: %w", err) } defer disksClient.Close() req := &computepb.InsertDiskRequest{ Project: projectID, Zone: zone, DiskResource: &computepb.Disk{ Name: proto.String(diskName), Zone: proto.String(zone), Type: proto.String(diskType), SourceSnapshot: proto.String(snapshotLink), SizeGb: proto.Int64(diskSizeGb), }, } op, err := disksClient.Insert(ctx, req) if err != nil { return fmt.Errorf("unable to create disk: %w", err) } if err = op.Wait(ctx); err != nil { return fmt.Errorf("unable to wait for the operation: %w", err) } fmt.Fprintf(w, "Disk created\n") return nil } Java Java Before trying this sample, follow the Java setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Java API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. import com.google.cloud.compute.v1.Disk; import com.google.cloud.compute.v1.DisksClient; import com.google.cloud.compute.v1.InsertDiskRequest; import com.google.cloud.compute.v1.Operation; import java.io.IOException; import java.util.concurrent.ExecutionException; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; public class CreateDiskFromSnapshot { public static void main(String[] args) throws IOException, ExecutionException, InterruptedException, TimeoutException { // TODO(developer): Replace these variables before running the sample. // Project ID or project number of the Cloud project you want to use. String projectId = "YOUR_PROJECT_ID"; // Name of the zone in which you want to create the disk. String zone = "europe-central2-b"; // Name of the disk you want to create. String diskName = "YOUR_DISK_NAME"; // The type of disk you want to create. This value uses the following format: // "zones/{zone}/diskTypes/(pd-standard|pd-ssd|pd-balanced|pd-extreme)". // For example: "zones/us-west3-b/diskTypes/pd-ssd" String diskType = String.format("zones/%s/diskTypes/pd-ssd", zone); // Size of the new disk in gigabytes. long diskSizeGb = 10; // The full path and name of the snapshot that you want to use as the source for the new disk. // This value uses the following format: // "projects/{projectName}/global/snapshots/{snapshotName}" String snapshotLink = String.format("projects/%s/global/snapshots/%s", projectId, "SNAPSHOT_NAME"); createDiskFromSnapshot(projectId, zone, diskName, diskType, diskSizeGb, snapshotLink); } // Creates a new disk in a project in given zone, using a snapshot. public static void createDiskFromSnapshot(String projectId, String zone, String diskName, String diskType, long diskSizeGb, String snapshotLink) throws IOException, ExecutionException, InterruptedException, TimeoutException { // Initialize client that will be used to send requests. This client only needs to be created // once, and can be reused for multiple requests. After completing all of your requests, call // the `disksClient.close()` method on the client to safely // clean up any remaining background resources. try (DisksClient disksClient = DisksClient.create()) { // Set the disk properties and the source snapshot. Disk disk = Disk.newBuilder() .setName(diskName) .setZone(zone) .setSizeGb(diskSizeGb) .setType(diskType) .setSourceSnapshot(snapshotLink) .build(); // Create the insert disk request. InsertDiskRequest insertDiskRequest = InsertDiskRequest.newBuilder() .setProject(projectId) .setZone(zone) .setDiskResource(disk) .build(); // Wait for the create disk operation to complete. Operation response = disksClient.insertAsync(insertDiskRequest) .get(3, TimeUnit.MINUTES); if (response.hasError()) { System.out.println("Disk creation failed!" + response); return; } System.out.println("Disk created. Operation Status: " + response.getStatus()); } } } Node.js Node.js Before trying this sample, follow the Node.js setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Node.js API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. /** * TODO(developer): Uncomment and replace these variables before running the sample. */ // const projectId = 'YOUR_PROJECT_ID'; // const zone = 'europe-central2-b'; // const diskName = 'YOUR_DISK_NAME'; // const diskType = 'zones/us-west3-b/diskTypes/pd-ssd'; // const diskSizeGb = 10; // const snapshotLink = 'projects/project_name/global/snapshots/snapshot_name'; const compute = require('@google-cloud/compute'); async function createDiskFromSnapshot() { const disksClient = new compute.DisksClient(); const [response] = await disksClient.insert({ project: projectId, zone, diskResource: { sizeGb: diskSizeGb, name: diskName, zone, type: diskType, sourceSnapshot: snapshotLink, }, }); let operation = response.latestResponse; const operationsClient = new compute.ZoneOperationsClient(); // Wait for the create disk operation to complete. while (operation.status !== 'DONE') { [operation] = await operationsClient.wait({ operation: operation.name, project: projectId, zone: operation.zone.split('/').pop(), }); } console.log('Disk created.'); } createDiskFromSnapshot(); Python Python Before trying this sample, follow the Python setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Python API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. from __future__ import annotations import sys from typing import Any from google.api_core.extended_operation import ExtendedOperation from google.cloud import compute_v1 def wait_for_extended_operation( operation: ExtendedOperation, verbose_name: str = "operation", timeout: int = 300 ) -> Any: """ Waits for the extended (long-running) operation to complete. If the operation is successful, it will return its result. If the operation ends with an error, an exception will be raised. If there were any warnings during the execution of the operation they will be printed to sys.stderr. Args: operation: a long-running operation you want to wait on. verbose_name: (optional) a more verbose name of the operation, used only during error and warning reporting. timeout: how long (in seconds) to wait for operation to finish. If None, wait indefinitely. Returns: Whatever the operation.result() returns. Raises: This method will raise the exception received from `operation.exception()` or RuntimeError if there is no exception set, but there is an `error_code` set for the `operation`. In case of an operation taking longer than `timeout` seconds to complete, a `concurrent.futures.TimeoutError` will be raised. """ result = operation.result(timeout=timeout) if operation.error_code: print( f"Error during {verbose_name}: [Code: {operation.error_code}]: {operation.error_message}", file=sys.stderr, flush=True, ) print(f"Operation ID: {operation.name}", file=sys.stderr, flush=True) raise operation.exception() or RuntimeError(operation.error_message) if operation.warnings: print(f"Warnings during {verbose_name}:\n", file=sys.stderr, flush=True) for warning in operation.warnings: print(f" - {warning.code}: {warning.message}", file=sys.stderr, flush=True) return result def create_disk_from_snapshot( project_id: str, zone: str, disk_name: str, disk_type: str, disk_size_gb: int, snapshot_link: str, ) -> compute_v1.Disk: """ Creates a new disk in a project in given zone. Args: project_id: project ID or project number of the Cloud project you want to use. zone: name of the zone in which you want to create the disk. disk_name: name of the disk you want to create. disk_type: the type of disk you want to create. This value uses the following format: "zones/{zone}/diskTypes/(pd-standard|pd-ssd|pd-balanced|pd-extreme)". For example: "zones/us-west3-b/diskTypes/pd-ssd" disk_size_gb: size of the new disk in gigabytes snapshot_link: a link to the snapshot you want to use as a source for the new disk. This value uses the following format: "projects/{project_name}/global/snapshots/{snapshot_name}" Returns: An unattached Disk instance. """ disk_client = compute_v1.DisksClient() disk = compute_v1.Disk() disk.zone = zone disk.size_gb = disk_size_gb disk.source_snapshot = snapshot_link disk.type_ = disk_type disk.name = disk_name operation = disk_client.insert(project=project_id, zone=zone, disk_resource=disk) wait_for_extended_operation(operation, "disk creation") return disk_client.get(project=project_id, zone=zone, disk=disk_name) REST Construct a GETrequest to snapshots.listto display the list of snapshots in your project. GET https://compute.googleapis.com/compute/v1/projects/PROJECT_ID/global/snapshots Replace PROJECT_ID with your project ID. Construct a POSTrequest to create a regional or zonal disk using the respective disks.insertmethod: - For zonal disks: disks.insert - For regional disks: regionDisks.insertfor regional disks Include the name, sizeGb, and typeproperties. To restore a disk using a snapshot, you must include the sourceSnapshotproperty. For example, the following requests creates a zonal disk: POST https://compute.googleapis.com/compute/v1/projects/PROJECT_ID/zones/ZONE/disks { "name": "DISK_NAME", "sizeGb": "DISK_SIZE", "type": "zones/ZONE/diskTypes/DISK_TYPE" "sourceSnapshot": "SNAPSHOT_NAME" } Replace the following: - PROJECT_ID: your project ID. - ZONE the zone where your instance and new disk are located. - DISK_NAME: the name of the new disk. - DISK_SIZE: the size of the new disk, in gigabytes. This number must be equal to or larger than the original source disk for the snapshot. - DISK_TYPE: full or partial URL for the type of the disk. For example https://www.googleapis.com/compute/v1/projects/PROJECT_ID/zones/ ZONE/diskTypes/pd-ssd. - SNAPSHOT_NAME: the source snapshot for the disk you are restoring. - For zonal disks: Optionally, you can then attach the new disk to an existing instance by constructing a POSTrequest to the instances.attachDiskmethod, and including the URL to the disk that you just created from your snapshot. For regional disks, replace zones/ZONEwith regions/REGION. POST https://compute.googleapis.com/compute/v1/projects/PROJECT_ID/zones/ZONE/instances/INSTANCE_NAME/attachDisk { "source": "/compute/v1/projects/PROJECT_ID/zones/ZONE/disks/DISK_NAME" } Replace the following: - PROJECT_ID is your project ID. - ZONE is the zone where your instance and new disk are located. - INSTANCE_NAME is the name of the instance where you are adding the new disk. - DISK_NAME is the name of the new disk. After you create and attach a new disk to an instance, you must mount the disk so that the operating system can use the available storage space. Create a VM from existing disks You can create boot disk and data disks from snapshots and then attach these disks to a new VM. Go Go Before trying this sample, follow the Go setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Go API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. import ( "context" "fmt" "io" compute "cloud.google.com/go/compute/apiv1" computepb "google.golang.org/genproto/googleapis/cloud/compute/v1" "google.golang.org/protobuf/proto" ) // createWithExistingDisks create a new VM instance using selected disks. // The first disk in diskNames will be used as boot disk. func createWithExistingDisks( w io.Writer, projectID, zone, instanceName string, diskNames []string, ) error { // projectID := "your_project_id" // zone := "europe-central2-b" // instanceName := "your_instance_name" // diskNames := []string{"boot_disk", "disk1", "disk2"} ctx := context.Background() instancesClient, err := compute.NewInstancesRESTClient(ctx) if err != nil { return fmt.Errorf("NewInstancesRESTClient: %w", err) } defer instancesClient.Close() disksClient, err := compute.NewDisksRESTClient(ctx) if err != nil { return fmt.Errorf("NewDisksRESTClient: %w", err) } defer disksClient.Close() disks := [](*computepb.Disk){} for _, diskName := range diskNames { reqDisk := &computepb.GetDiskRequest{ Project: projectID, Zone: zone, Disk: diskName, } disk, err := disksClient.Get(ctx, reqDisk) if err != nil { return fmt.Errorf("unable to get disk: %w", err) } disks = append(disks, disk) } attachedDisks := [](*computepb.AttachedDisk){} for _, disk := range disks { attachedDisk := &computepb.AttachedDisk{ Source: proto.String(disk.GetSelfLink()), } attachedDisks = append(attachedDisks, attachedDisk) } attachedDisks[0].Boot = proto.Bool(true) instanceResource := &computepb.Instance{ Name: proto.String(instanceName), Disks: attachedDisks, MachineType: proto.String(fmt.Sprintf("zones/%s/machineTypes/n1-standard-1", zone)), NetworkInterfaces: []*computepb.NetworkInterface{ { Name: proto.String("global/networks/default"), }, }, } req := &computepb.InsertInstanceRequest{ Project: projectID, Zone: zone, InstanceResource: instanceResource, } op, err := instancesClient.Insert(ctx, req) if err != nil { return fmt.Errorf("unable to create instance: %w", err) } if err = op.Wait(ctx); err != nil { return fmt.Errorf("unable to wait for the operation: %w", err) } fmt.Fprintf(w, "Instance created\n") return nil } Java Java Before trying this sample, follow the Java setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Java API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. import com.google.cloud.compute.v1.AttachedDisk; import com.google.cloud.compute.v1.Disk; import com.google.cloud.compute.v1.DisksClient; import com.google.cloud.compute.v1.InsertInstanceRequest; import com.google.cloud.compute.v1.Instance; import com.google.cloud.compute.v1.InstancesClient; import com.google.cloud.compute.v1.NetworkInterface; import com.google.cloud.compute.v1.Operation; import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.util.concurrent.ExecutionException; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; public class CreateInstanceWithExistingDisks { public static void main(String[] args) throws IOException, ExecutionException, InterruptedException, TimeoutException { // TODO(developer): Replace these variables before running the sample. // Project ID or project number of the Cloud project you want to use. String projectId = "YOUR_PROJECT_ID"; // Name of the zone to create the instance in. For example: "us-west3-b" String zone = "europe-central2-b"; // Name of the new virtual machine (VM) instance. String instanceName = "YOUR_INSTANCE_NAME"; // Array of disk names to be attached to the new virtual machine. // First disk in this list will be used as the boot disk. List<String> diskNames = List.of("your-boot-disk", "another-disk1", "another-disk2"); createInstanceWithExistingDisks(projectId, zone, instanceName, diskNames); } // Create a new VM instance using the selected disks. // The first disk in diskNames will be used as the boot disk. public static void createInstanceWithExistingDisks(String projectId, String zone, String instanceName, List<String> diskNames) throws IOException, ExecutionException, InterruptedException, TimeoutException { // Initialize client that will be used to send requests. This client only needs to be created // once, and can be reused for multiple requests. After completing all of your requests, call // the `instancesClient.close()` method on the client to safely // clean up any remaining background resources. try (InstancesClient instancesClient = InstancesClient.create(); DisksClient disksClient = DisksClient.create()) { if (diskNames.size() == 0) { throw new Error("At least one disk should be provided"); } // Create the list of attached disks to be used in instance creation. List<AttachedDisk> attachedDisks = new ArrayList<>(); for (int i = 0; i < diskNames.size(); i++) { String diskName = diskNames.get(i); Disk disk = disksClient.get(projectId, zone, diskName); AttachedDisk attDisk = null; if (i == 0) { // Make the first disk in the list as the boot disk. attDisk = AttachedDisk.newBuilder() .setSource(disk.getSelfLink()) .setBoot(true) .build(); } else { attDisk = AttachedDisk.newBuilder() .setSource(disk.getSelfLink()) .build(); } attachedDisks.add(attDisk); } // Create the instance. Instance instance = Instance.newBuilder() .setName(instanceName) // Add the attached disks to the instance. .addAllDisks(attachedDisks) .setMachineType(String.format("zones/%s/machineTypes/n1-standard-1", zone)) .addNetworkInterfaces( NetworkInterface.newBuilder().setName("global/networks/default").build()) .build(); // Create the insert instance request. InsertInstanceRequest insertInstanceRequest = InsertInstanceRequest.newBuilder() .setProject(projectId) .setZone(zone) .setInstanceResource(instance) .build(); // Wait for the create operation to complete. Operation response = instancesClient.insertAsync(insertInstanceRequest) .get(3, TimeUnit.MINUTES); if (response.hasError()) { System.out.println("Instance creation failed!" + response); return; } System.out.println("Operation Status: " + response.getStatus()); } } } Node.js Node.js Before trying this sample, follow the Node.js setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Node.js API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. /** * TODO(developer): Uncomment and replace these variables before running the sample. */ // const projectId = 'YOUR_PROJECT_ID'; // const zone = 'europe-central2-b'; // const instanceName = 'YOUR_INSTANCE_NAME'; // const diskNames = ['boot_disk', 'disk1', 'disk2']; const compute = require('@google-cloud/compute'); async function createWithExistingDisks() { const instancesClient = new compute.InstancesClient(); const disksClient = new compute.DisksClient(); if (diskNames.length < 1) { throw new Error('At least one disk should be provided'); } const disks = []; for (const diskName of diskNames) { const [disk] = await disksClient.get({ project: projectId, zone, disk: diskName, }); disks.push(disk); } const attachedDisks = []; for (const disk of disks) { attachedDisks.push({ source: disk.selfLink, }); } attachedDisks[0].boot = true; const [response] = await instancesClient.insert({ project: projectId, zone, instanceResource: { name: instanceName, disks: attachedDisks, machineType: `zones/${zone}/machineTypes/n1-standard-1`, networkInterfaces: [ { name: 'global/networks/default', }, ], }, }); let operation = response.latestResponse; const operationsClient = new compute.ZoneOperationsClient(); // Wait for the create operation to complete. while (operation.status !== 'DONE') { [operation] = await operationsClient.wait({ operation: operation.name, project: projectId, zone: operation.zone.split('/').pop(), }); } console.log('Instance created.'); } createWithExistingDisks(); Python Python Before trying this sample, follow the Python setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Python API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. from __future__ import annotations import re import sys from typing import Any import warnings from google.api_core.extended_operation import ExtendedOperation from google.cloud import compute_v1 def get_disk(project_id: str, zone: str, disk_name: str) -> compute_v1.Disk: """ Gets a disk from a project. Args: project_id: project ID or project number of the Cloud project you want to use. zone: name of the zone where the disk exists. disk_name: name of the disk you want to retrieve. """ disk_client = compute_v1.DisksClient() return disk_client.get(project=project_id, zone=zone, disk=disk_name) def wait_for_extended_operation( operation: ExtendedOperation, verbose_name: str = "operation", timeout: int = 300 ) -> Any: """ Waits for the extended (long-running) operation to complete. If the operation is successful, it will return its result. If the operation ends with an error, an exception will be raised. If there were any warnings during the execution of the operation they will be printed to sys.stderr. Args: operation: a long-running operation you want to wait on. verbose_name: (optional) a more verbose name of the operation, used only during error and warning reporting. timeout: how long (in seconds) to wait for operation to finish. If None, wait indefinitely. Returns: Whatever the operation.result() returns. Raises: This method will raise the exception received from `operation.exception()` or RuntimeError if there is no exception set, but there is an `error_code` set for the `operation`. In case of an operation taking longer than `timeout` seconds to complete, a `concurrent.futures.TimeoutError` will be raised. """ result = operation.result(timeout=timeout) if operation.error_code: print( f"Error during {verbose_name}: [Code: {operation.error_code}]: {operation.error_message}", file=sys.stderr, flush=True, ) print(f"Operation ID: {operation.name}", file=sys.stderr, flush=True) raise operation.exception() or RuntimeError(operation.error_message) if operation.warnings: print(f"Warnings during {verbose_name}:\n", file=sys.stderr, flush=True) for warning in operation.warnings: print(f" - {warning.code}: {warning.message}", file=sys.stderr, flush=True) return result def create_instance( project_id: str, zone: str, instance_name: str, disks: list[compute_v1.AttachedDisk], machine_type: str = "n1-standard-1", network_link: str = "global/networks/default", subnetwork_link: str = None, internal_ip: str = None, external_access: bool = False, external_ipv4: str = None, accelerators: list[compute_v1.AcceleratorConfig] = None, preemptible: bool = False, spot: bool = False, instance_termination_action: str = "STOP", custom_hostname: str = None, delete_protection: bool = False, ) -> compute_v1.Instance: """ Send an instance creation request to the Compute Engine API and wait for it to complete. Args: project_id: project ID or project number of the Cloud project you want to use. zone: name of the zone to create the instance in. For example: "us-west3-b" instance_name: name of the new virtual machine (VM) instance. disks: a list of compute_v1.AttachedDisk objects describing the disks you want to attach to your new instance. machine_type: machine type of the VM being created. This value uses the following format: "zones/{zone}/machineTypes/{type_name}". For example: "zones/europe-west3-c/machineTypes/f1-micro" network_link: name of the network you want the new instance to use. For example: "global/networks/default" represents the network named "default", which is created automatically for each project. subnetwork_link: name of the subnetwork you want the new instance to use. This value uses the following format: "regions/{region}/subnetworks/{subnetwork_name}" internal_ip: internal IP address you want to assign to the new instance. By default, a free address from the pool of available internal IP addresses of used subnet will be used. external_access: boolean flag indicating if the instance should have an external IPv4 address assigned. external_ipv4: external IPv4 address to be assigned to this instance. If you specify an external IP address, it must live in the same region as the zone of the instance. This setting requires `external_access` to be set to True to work. accelerators: a list of AcceleratorConfig objects describing the accelerators that will be attached to the new instance. preemptible: boolean value indicating if the new instance should be preemptible or not. Preemptible VMs have been deprecated and you should now use Spot VMs. spot: boolean value indicating if the new instance should be a Spot VM or not. instance_termination_action: What action should be taken once a Spot VM is terminated. Possible values: "STOP", "DELETE" custom_hostname: Custom hostname of the new VM instance. Custom hostnames must conform to RFC 1035 requirements for valid hostnames. delete_protection: boolean value indicating if the new virtual machine should be protected against deletion or not. Returns: Instance object. """ instance_client = compute_v1.InstancesClient() # Use the network interface provided in the network_link argument. network_interface = compute_v1.NetworkInterface() network_interface.network = network_link if subnetwork_link: network_interface.subnetwork = subnetwork_link if internal_ip: network_interface.network_i_p = internal_ip if external_access: access = compute_v1.AccessConfig() access.type_ = compute_v1.AccessConfig.Type.ONE_TO_ONE_NAT.name access.name = "External NAT" access.network_tier = access.NetworkTier.PREMIUM.name if external_ipv4: access.nat_i_p = external_ipv4 network_interface.access_configs = [access] # Collect information into the Instance object. instance = compute_v1.Instance() instance.network_interfaces = [network_interface] instance.name = instance_name instance.disks = disks if re.match(r"^zones/[a-z\d\-]+/machineTypes/[a-z\d\-]+$", machine_type): instance.machine_type = machine_type else: instance.machine_type = f"zones/{zone}/machineTypes/{machine_type}" instance.scheduling = compute_v1.Scheduling() if accelerators: instance.guest_accelerators = accelerators instance.scheduling.on_host_maintenance = ( compute_v1.Scheduling.OnHostMaintenance.TERMINATE.name ) if preemptible: # Set the preemptible setting warnings.warn( "Preemptible VMs are being replaced by Spot VMs.", DeprecationWarning ) instance.scheduling = compute_v1.Scheduling() instance.scheduling.preemptible = True if spot: # Set the Spot VM setting instance.scheduling.provisioning_model = ( compute_v1.Scheduling.ProvisioningModel.SPOT.name ) instance.scheduling.instance_termination_action = instance_termination_action if custom_hostname is not None: # Set the custom hostname for the instance instance.hostname = custom_hostname if delete_protection: # Set the delete protection bit instance.deletion_protection = True # Prepare the request to insert an instance. request = compute_v1.InsertInstanceRequest() request.zone = zone request.project = project_id request.instance_resource = instance # Wait for the create operation to complete. print(f"Creating the {instance_name} instance in {zone}...") operation = instance_client.insert(request=request) wait_for_extended_operation(operation, "instance creation") print(f"Instance {instance_name} created.") return instance_client.get(project=project_id, zone=zone, instance=instance_name) def create_with_existing_disks( project_id: str, zone: str, instance_name: str, disk_names: list[str] ) -> compute_v1.Instance: """ Create a new VM instance using selected disks. The first disk in disk_names will be used as boot disk. Args: project_id: project ID or project number of the Cloud project you want to use. zone: name of the zone to create the instance in. For example: "us-west3-b" instance_name: name of the new virtual machine (VM) instance. disk_names: list of disk names to be attached to the new virtual machine. First disk in this list will be used as the boot device. Returns: Instance object. """ assert len(disk_names) >= 1 disks = [get_disk(project_id, zone, disk_name) for disk_name in disk_names] attached_disks = [] for disk in disks: adisk = compute_v1.AttachedDisk() adisk.source = disk.self_link attached_disks.append(adisk) attached_disks[0].boot = True instance = create_instance(project_id, zone, instance_name, attached_disks) return instance Create a VM from a boot disk snapshot If you backed up a VM's boot disk with a snapshot, you can use that snapshot to create a new VM. To create a VM with a regional Persistent Disk boot disk from a snapshot, use the Google Cloud CLI or the Compute Engine API. Permissions required for this task To perform this task, you must have the following permissions: compute.instances.createon the project compute.instances.updateShieldedVmConfigif you plan to create a Shielded VM instance and you want to be able to change any of the Shielded VM settings compute.networks.useon the project if using a legacy network compute.subnetworks.useeither on the whole project or on the chosen subnet (VPC networks) compute.networks.useExternalIpon the project if you need to assign an external IP address (either ephemeral or static) to the instance using a legacy network compute.subnetworks.useExternalIpeither on the whole project or on the chosen subnet if you need to assign an external IP address (either ephemeral or static) to the instance using a VPC network compute.addresses.useon the project if specifying a static address in the project compute.instances.setMetadataif setting metadata compute.instances.setTagson the instance if setting tags compute.instances.setLabelson the instance if setting labels compute.instances.setServiceAccounton the instance if setting service account compute.images.useReadOnlyon the image if creating a new root persistent disk compute.disks.createon the project if creating a new root persistent disk with this instance compute.disks.useReadOnlyon the disk if attaching an existing persistent disk in read-only mode compute.disks.useon the disk if attaching an existing disk in read/write mode compute.disks.setLabelson the disk if setting labels compute.snapshots.createon the project to create a new snapshot if creating an instance from a snapshot compute.snapshots.useReadOnlyon the snapshot if creating an instance from a snapshot compute.instanceTemplates.useReadOnlyon the instance template if creating instance from instance template Console In the Google Cloud console, go to the VM instances page. Select your project and click Continue. Click Create instance. Specify a Name for your VM. For more information, see Resource naming convention. Optional: Change the Zone for this VM. Compute Engine randomizes the list of zones within each region to encourage use across multiple zones. Select a Machine configuration for your VM. In the Boot disk section, click Change, and then do the following: - Click the Snapshots tab. - In the Snapshot list, click a snapshot. - Specify the boot disk type and size. - Optional: For advanced configuration options, click Show advanced configurations. - To confirm your boot disk options, click Select. In the Firewall section, to permit HTTP or HTTPS traffic to the VM, select Allow HTTP traffic or Allow HTTPS traffic. The Google Cloud console adds a network tag to your VM and creates the corresponding ingress firewall rule that allows all incoming traffic on tcp:80(HTTP) or tcp:443(HTTPS). The network tag associates the firewall rule with the VM. For more information, see Firewall rules overview in the Virtual Private Cloud documentation. To create and start the VM, click Create. gcloud Persistent Disk boot disk Use the gcloud compute instances create command and include the --source-snapshot flag. gcloud compute instances create VM_NAME \ --source-snapshot=BOOT_SNAPSHOT_NAME \ --boot-disk-size=BOOT_DISK_SIZE \ --boot-disk-type=BOOT_DISK_TYPE \ --boot-disk-device-name=BOOT_DISK_NAME Replace the following: VM_NAME: name for the new VM BOOT_SNAPSHOT_NAME: name of the boot disk snapshot that you want to restore to the boot disk of the new VM. BOOT_DISK_SIZE: Optional: size, in gigabytes, of the new boot disk The size must be equal to or larger than the size of the source disk from which the snapshot was made. BOOT_DISK_TYPE: Optional: type of the boot persistent disk, for example, pd-ssd. BOOT_DISK_NAME: name of the new boot disk for this VM Regional Persistent Disk boot disk Use the gcloud compute instances create command and include the --create-disk flag with the source-snapshot, replica-zones, and boot properties. gcloud compute instances create VM_NAME \ --zone=ZONE \ --create-disk=^:^name=DISK_NAME:source-snapshot=BOOT_SNAPSHOT_NAME:boot=true:replica-zones=ZONE,REMOTE_ZONE The characters ^:^ specify that a colon : is used as the separator between each of the disk properties. This is required so that you can use a comma , when specifying the zones for replica-zones. Replace the following: VM_NAME: name for the new VM ZONE: To zone to create the VM in DISK_NAME: Optional: a name for the disk BOOT_SNAPSHOT_NAME: name of the boot disk snapshot that you want to restore to the boot disk of the new VM. REMOTE_ZONE: The region that the regional Persistent Disk is replicated to.The replica-zonesproperty requires two zones separated by comma, and one of the zones must the same as the zone for the VM. Go Go Before trying this sample, follow the Go setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Go API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. import ( "context" "fmt" "io" compute "cloud.google.com/go/compute/apiv1" computepb "google.golang.org/genproto/googleapis/cloud/compute/v1" "google.golang.org/protobuf/proto" ) // createInstanceFromSnapshot creates a new VM instance with boot disk created from a snapshot. func createInstanceFromSnapshot(w io.Writer, projectID, zone, instanceName, snapshotLink string) error { // projectID := "your_project_id" // zone := "europe-central2-b" // instanceName := "your_instance_name" // snapshotLink := "projects/project_name/global/snapshots/snapshot_name" ctx := context.Background() instancesClient, err := compute.NewInstancesRESTClient(ctx) if err != nil { return fmt.Errorf("NewInstancesRESTClient: %w", err) } defer instancesClient.Close() req := &computepb.InsertInstanceRequest{ Project: projectID, Zone: zone, InstanceResource: &computepb.Instance{ Name: proto.String(instanceName), Disks: []*computepb.AttachedDisk{ { InitializeParams: &computepb.AttachedDiskInitializeParams{ DiskSizeGb: proto.Int64(11), SourceSnapshot: proto.String(snapshotLink), DiskType: proto.String(fmt.Sprintf("zones/%s/diskTypes/pd-standard", zone)), }, AutoDelete: proto.Bool(true), Boot: proto.Bool(true), Type: proto.String(computepb.AttachedDisk_PERSISTENT.String()), }, }, MachineType: proto.String(fmt.Sprintf("zones/%s/machineTypes/n1-standard-1", zone)), NetworkInterfaces: []*computepb.NetworkInterface{ { Name: proto.String("global/networks/default"), }, }, }, } op, err := instancesClient.Insert(ctx, req) if err != nil { return fmt.Errorf("unable to create instance: %w", err) } if err = op.Wait(ctx); err != nil { return fmt.Errorf("unable to wait for the operation: %w", err) } fmt.Fprintf(w, "Instance created\n") return nil } Java Java Before trying this sample, follow the Java setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Java API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. import com.google.api.gax.longrunning.OperationFuture; import com.google.cloud.compute.v1.AttachedDisk; import com.google.cloud.compute.v1.AttachedDisk.Type; import com.google.cloud.compute.v1.AttachedDiskInitializeParams; import com.google.cloud.compute.v1.Image; import com.google.cloud.compute.v1.ImagesClient; import com.google.cloud.compute.v1.InsertInstanceRequest; import com.google.cloud.compute.v1.Instance; import com.google.cloud.compute.v1.InstancesClient; import com.google.cloud.compute.v1.NetworkInterface; import com.google.cloud.compute.v1.Operation; import java.io.IOException; import java.util.Vector; import java.util.concurrent.ExecutionException; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; public class CreateInstancesAdvanced { /** * @param diskType the type of disk you want to create. This value uses the following format: * "zones/{zone}/diskTypes/(pd-standard|pd-ssd|pd-balanced|pd-extreme)". For example: * "zones/us-west3-b/diskTypes/pd-ssd" * @param diskSizeGb size of the new disk in gigabytes * @param boot boolean flag indicating whether this disk should be used as a boot disk of an * instance * @param diskSnapshot disk snapshot to use when creating this disk. You must have read access to * this disk. This value uses the following format: * "projects/{project_name}/global/snapshots/{snapshot_name}" * @return AttachedDisk object configured to be created using the specified snapshot. */ private static AttachedDisk diskFromSnapshot(String diskType, int diskSizeGb, boolean boot, String diskSnapshot) { AttachedDisk disk = AttachedDisk.newBuilder() .setBoot(boot) // Remember to set auto_delete to True if you want the disk to be deleted when // you delete your VM instance. .setAutoDelete(true) .setType(Type.PERSISTENT.toString()) .setInitializeParams( AttachedDiskInitializeParams.newBuilder() .setSourceSnapshot(diskSnapshot) .setDiskSizeGb(diskSizeGb) .setDiskType(diskType) .build()) .build(); return disk; } /** * Send an instance creation request to the Compute Engine API and wait for it to complete. * * @param project project ID or project number of the Cloud project you want to use. * @param zone name of the zone to create the instance in. For example: "us-west3-b" * @param instanceName name of the new virtual machine (VM) instance. * @param disks a list of compute_v1.AttachedDisk objects describing the disks you want to attach * to your new instance. * @param machineType machine type of the VM being created. This value uses the following format: * "zones/{zone}/machineTypes/{type_name}". * For example: "zones/europe-west3-c/machineTypes/f1-micro" * @param network name of the network you want the new instance to use. For example: * "global/networks/default" represents the network named "default", which is created * automatically for each project. * @param subnetwork name of the subnetwork you want the new instance to use. This value uses the * following format: "regions/{region}/subnetworks/{subnetwork_name}" * @return Instance object. */ private static Instance createWithDisks(String project, String zone, String instanceName, Vector<AttachedDisk> disks, String machineType, String network, String subnetwork) throws IOException, InterruptedException, ExecutionException, TimeoutException { try (InstancesClient instancesClient = InstancesClient.create()) { // Use the network interface provided in the networkName argument. NetworkInterface networkInterface; if (subnetwork != null) { networkInterface = NetworkInterface.newBuilder() .setName(network).setSubnetwork(subnetwork) .build(); } else { networkInterface = NetworkInterface.newBuilder() .setName(network).build(); } machineType = String.format("zones/%s/machineTypes/%s", zone, machineType); // Bind `instanceName`, `machineType`, `disk`, and `networkInterface` to an instance. Instance instanceResource = Instance.newBuilder() .setName(instanceName) .setMachineType(machineType) .addAllDisks(disks) .addNetworkInterfaces(networkInterface) .build(); System.out.printf("Creating instance: %s at %s ", instanceName, zone); // Insert the instance in the specified project and zone. InsertInstanceRequest insertInstanceRequest = InsertInstanceRequest.newBuilder() .setProject(project) .setZone(zone) .setInstanceResource(instanceResource).build(); OperationFuture<Operation, Operation> operation = instancesClient.insertAsync( insertInstanceRequest); // Wait for the operation to complete. Operation response = operation.get(3, TimeUnit.MINUTES); if (response.hasError()) { System.out.println("Instance creation failed ! ! " + response); return null; } System.out.println("Operation Status: " + response.getStatus()); return instancesClient.get(project, zone, instanceName); } } /** * Create a new VM instance with boot disk created from a snapshot. * * @param project project ID or project number of the Cloud project you want to use. * @param zone name of the zone to create the instance in. For example: "us-west3-b" * @param instanceName name of the new virtual machine (VM) instance. * @param snapshotName link to the snapshot you want to use as the source of your boot disk in the * form of: "projects/{project_name}/global/snapshots/{snapshot_name}" * @return Instance object. */ public static Instance createFromSnapshot(String project, String zone, String instanceName, String snapshotName) throws IOException, InterruptedException, ExecutionException, TimeoutException { String diskType = String.format("zones/%s/diskTypes/pd-standard", zone); Vector<AttachedDisk> disks = new Vector<>(); disks.add(diskFromSnapshot(diskType, 11, true, snapshotName)); return createWithDisks(project, zone, instanceName, disks, "n1-standard-1", "global/networks/default", null); } Node.js Node.js Before trying this sample, follow the Node.js setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Node.js API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. /** * TODO(developer): Uncomment and replace these variables before running the sample. */ // const projectId = 'YOUR_PROJECT_ID'; // const zone = 'europe-central2-b'; // const instanceName = 'YOUR_INSTANCE_NAME'; // const snapshotLink = 'projects/YOUR_PROJECT/global/snapshots/YOUR_SNAPSHOT_NAME'; const compute = require('@google-cloud/compute'); // Creates a new VM instance with boot disk created from a snapshot. async function createInstanceFromSnapshot() { const instancesClient = new compute.InstancesClient(); const [response] = await instancesClient.insert({ project: projectId, zone, instanceResource: { name: instanceName, disks: [ { initializeParams: { diskSizeGb: '11', sourceSnapshot: snapshotLink, diskType: `zones/${zone}/diskTypes/pd-standard`, }, autoDelete: true, boot: true, type: 'PERSISTENT', }, ], machineType: `zones/${zone}/machineTypes/n1-standard-1`, networkInterfaces: [ { name: 'global/networks/default', }, ], }, }); let operation = response.latestResponse; const operationsClient = new compute.ZoneOperationsClient(); // Wait for the create operation to complete. while (operation.status !== 'DONE') { [operation] = await operationsClient.wait({ operation: operation.name, project: projectId, zone: operation.zone.split('/').pop(), }); } console.log('Instance created.'); } createInstanceFromSnapshot(); Python Python Before trying this sample, follow the Python setup instructions in the Compute Engine quickstart using client libraries. For more information, see the Compute Engine Python API reference documentation. To authenticate to Compute Engine, set up Application Default Credentials. For more information, see Set up authentication for a local development environment. from __future__ import annotations import re import sys from typing import Any import warnings from google.api_core.extended_operation import ExtendedOperation from google.cloud import compute_v1 def disk_from_snapshot( disk_type: str, disk_size_gb: int, boot: bool, source_snapshot: str, auto_delete: bool = True, ) -> compute_v1.AttachedDisk(): """ Create an AttachedDisk object to be used in VM instance creation. Uses a disk snapshot as the source for the new disk. Args: disk_type: the type of disk you want to create. This value uses the following format: "zones/{zone}/diskTypes/(pd-standard|pd-ssd|pd-balanced|pd-extreme)". For example: "zones/us-west3-b/diskTypes/pd-ssd" disk_size_gb: size of the new disk in gigabytes boot: boolean flag indicating whether this disk should be used as a boot disk of an instance source_snapshot: disk snapshot to use when creating this disk. You must have read access to this disk. This value uses the following format: "projects/{project_name}/global/snapshots/{snapshot_name}" auto_delete: boolean flag indicating whether this disk should be deleted with the VM that uses it Returns: AttachedDisk object configured to be created using the specified snapshot. """ disk = compute_v1.AttachedDisk() initialize_params = compute_v1.AttachedDiskInitializeParams() initialize_params.source_snapshot = source_snapshot initialize_params.disk_type = disk_type initialize_params.disk_size_gb = disk_size_gb disk.initialize_params = initialize_params # Remember to set auto_delete to True if you want the disk to be deleted when you delete # your VM instance. disk.auto_delete = auto_delete disk.boot = boot return disk def wait_for_extended_operation( operation: ExtendedOperation, verbose_name: str = "operation", timeout: int = 300 ) -> Any: """ Waits for the extended (long-running) operation to complete. If the operation is successful, it will return its result. If the operation ends with an error, an exception will be raised. If there were any warnings during the execution of the operation they will be printed to sys.stderr. Args: operation: a long-running operation you want to wait on. verbose_name: (optional) a more verbose name of the operation, used only during error and warning reporting. timeout: how long (in seconds) to wait for operation to finish. If None, wait indefinitely. Returns: Whatever the operation.result() returns. Raises: This method will raise the exception received from `operation.exception()` or RuntimeError if there is no exception set, but there is an `error_code` set for the `operation`. In case of an operation taking longer than `timeout` seconds to complete, a `concurrent.futures.TimeoutError` will be raised. """ result = operation.result(timeout=timeout) if operation.error_code: print( f"Error during {verbose_name}: [Code: {operation.error_code}]: {operation.error_message}", file=sys.stderr, flush=True, ) print(f"Operation ID: {operation.name}", file=sys.stderr, flush=True) raise operation.exception() or RuntimeError(operation.error_message) if operation.warnings: print(f"Warnings during {verbose_name}:\n", file=sys.stderr, flush=True) for warning in operation.warnings: print(f" - {warning.code}: {warning.message}", file=sys.stderr, flush=True) return result def create_instance( project_id: str, zone: str, instance_name: str, disks: list[compute_v1.AttachedDisk], machine_type: str = "n1-standard-1", network_link: str = "global/networks/default", subnetwork_link: str = None, internal_ip: str = None, external_access: bool = False, external_ipv4: str = None, accelerators: list[compute_v1.AcceleratorConfig] = None, preemptible: bool = False, spot: bool = False, instance_termination_action: str = "STOP", custom_hostname: str = None, delete_protection: bool = False, ) -> compute_v1.Instance: """ Send an instance creation request to the Compute Engine API and wait for it to complete. Args: project_id: project ID or project number of the Cloud project you want to use. zone: name of the zone to create the instance in. For example: "us-west3-b" instance_name: name of the new virtual machine (VM) instance. disks: a list of compute_v1.AttachedDisk objects describing the disks you want to attach to your new instance. machine_type: machine type of the VM being created. This value uses the following format: "zones/{zone}/machineTypes/{type_name}". For example: "zones/europe-west3-c/machineTypes/f1-micro" network_link: name of the network you want the new instance to use. For example: "global/networks/default" represents the network named "default", which is created automatically for each project. subnetwork_link: name of the subnetwork you want the new instance to use. This value uses the following format: "regions/{region}/subnetworks/{subnetwork_name}" internal_ip: internal IP address you want to assign to the new instance. By default, a free address from the pool of available internal IP addresses of used subnet will be used. external_access: boolean flag indicating if the instance should have an external IPv4 address assigned. external_ipv4: external IPv4 address to be assigned to this instance. If you specify an external IP address, it must live in the same region as the zone of the instance. This setting requires `external_access` to be set to True to work. accelerators: a list of AcceleratorConfig objects describing the accelerators that will be attached to the new instance. preemptible: boolean value indicating if the new instance should be preemptible or not. Preemptible VMs have been deprecated and you should now use Spot VMs. spot: boolean value indicating if the new instance should be a Spot VM or not. instance_termination_action: What action should be taken once a Spot VM is terminated. Possible values: "STOP", "DELETE" custom_hostname: Custom hostname of the new VM instance. Custom hostnames must conform to RFC 1035 requirements for valid hostnames. delete_protection: boolean value indicating if the new virtual machine should be protected against deletion or not. Returns: Instance object. """ instance_client = compute_v1.InstancesClient() # Use the network interface provided in the network_link argument. network_interface = compute_v1.NetworkInterface() network_interface.network = network_link if subnetwork_link: network_interface.subnetwork = subnetwork_link if internal_ip: network_interface.network_i_p = internal_ip if external_access: access = compute_v1.AccessConfig() access.type_ = compute_v1.AccessConfig.Type.ONE_TO_ONE_NAT.name access.name = "External NAT" access.network_tier = access.NetworkTier.PREMIUM.name if external_ipv4: access.nat_i_p = external_ipv4 network_interface.access_configs = [access] # Collect information into the Instance object. instance = compute_v1.Instance() instance.network_interfaces = [network_interface] instance.name = instance_name instance.disks = disks if re.match(r"^zones/[a-z\d\-]+/machineTypes/[a-z\d\-]+$", machine_type): instance.machine_type = machine_type else: instance.machine_type = f"zones/{zone}/machineTypes/{machine_type}" instance.scheduling = compute_v1.Scheduling() if accelerators: instance.guest_accelerators = accelerators instance.scheduling.on_host_maintenance = ( compute_v1.Scheduling.OnHostMaintenance.TERMINATE.name ) if preemptible: # Set the preemptible setting warnings.warn( "Preemptible VMs are being replaced by Spot VMs.", DeprecationWarning ) instance.scheduling = compute_v1.Scheduling() instance.scheduling.preemptible = True if spot: # Set the Spot VM setting instance.scheduling.provisioning_model = ( compute_v1.Scheduling.ProvisioningModel.SPOT.name ) instance.scheduling.instance_termination_action = instance_termination_action if custom_hostname is not None: # Set the custom hostname for the instance instance.hostname = custom_hostname if delete_protection: # Set the delete protection bit instance.deletion_protection = True # Prepare the request to insert an instance. request = compute_v1.InsertInstanceRequest() request.zone = zone request.project = project_id request.instance_resource = instance # Wait for the create operation to complete. print(f"Creating the {instance_name} instance in {zone}...") operation = instance_client.insert(request=request) wait_for_extended_operation(operation, "instance creation") print(f"Instance {instance_name} created.") return instance_client.get(project=project_id, zone=zone, instance=instance_name) def create_from_snapshot( project_id: str, zone: str, instance_name: str, snapshot_link: str ): """ Create a new VM instance with boot disk created from a snapshot. The new boot disk will have 20 gigabytes. Args: project_id: project ID or project number of the Cloud project you want to use. zone: name of the zone to create the instance in. For example: "us-west3-b" instance_name: name of the new virtual machine (VM) instance. snapshot_link: link to the snapshot you want to use as the source of your boot disk in the form of: "projects/{project_name}/global/snapshots/{snapshot_name}" Returns: Instance object. """ disk_type = f"zones/{zone}/diskTypes/pd-standard" disks = [disk_from_snapshot(disk_type, 20, True, snapshot_link)] instance = create_instance(project_id, zone, instance_name, disks) return instance REST When you use the API to create a VM from a snapshot, the following restrictions apply: - Only one persistent disk can be used as the boot disk. - You must attach the boot disk as the first disk for that VM. - If you specify the sourceproperty, you cannot also specify the initializeParamsproperty. Providing a sourceindicates that the boot persistent disk exists already, but the initializeParamsproperty indicates that Compute Engine should create a new boot persistent disk. Persistent Disk boot diskTo create a VM from a boot disk snapshot, use the instances.insert method and specify the sourceSnapshot field under the disks property. Optional: specify the diskSizeGb and diskType properties for the new boot disk. POST https://compute.googleapis.com/compute/v1/projects/PROJECT_ID/zones/ZONE/instances { "name": "VM_NAME", "machineType": "machineTypes/MACHINE_TYPE" "networkInterfaces": [{ "accessConfigs": [{ "type": "ONE_TO_ONE_NAT", "name": "External NAT" }], "network": "global/networks/default" }], "disks": [{ "boot": true, "initializeParams": { "sourceSnapshot": "global/snapshots/BOOT_SNAPSHOT_NAME", "diskSizeGb": "BOOT_DISK_SIZE", "diskType": "BOOT_DISK_TYPE" } }], }Replace the following: PROJECT_ID: your project ID ZONE: zone where you want to create the new VM VM_NAME: name of the VM that you want to restore a snapshot to MACHINE_TYPE: machine type of the VM BOOT_SNAPSHOT_NAME: name of the snapshot that you want to use to create the boot disk of a new VM BOOT_DISK_SIZE: Optional: size, in gigabytes, for the new boot disk The size must be equal to or larger than the size of the source disk from which the snapshot was made. BOOT_DISK_TYPE: Optional: type of the boot disk, for example, `pd-ssd`. Regional Persistent Disk boot diskTo create a VM with a regional Persistent Disk for the boot disk from a boot disk snapshot, use the instances.insert method and specify the sourceSnapshot and replicaZones fields in the disks property. POST https://compute.googleapis.com/compute/v1/projects/PROJECT_ID/zones/ZONE/instances { "name": "VM_NAME", "disks": [{ "boot": true, "initializeParams": { "sourceSnapshot": "global/snapshots/BOOT_SNAPSHOT_NAME", "replicaZones": [ "projects/PROJECT_ID/zones/ZONE", "projects/PROJECT_ID/zones/REMOTE_ZONE"] } }], } Replace the following: PROJECT_ID: your project ID ZONE: the name of the zone where you want to create the VM VM_NAME`: a name for the VM BOOT_SNAPSHOT_NAME: the name of the boot disk snapshot REMOTE_ZONE: the remote zone for the regional Persistent Disk Create a VM from a non-boot disk snapshot If you backed up a non-boot disk with a snapshot, you can create a VM with a new non-boot disk based on the snapshot. Permissions required for this task To perform this task, you must have the following permissions: compute.instances.createon the project compute.instances.updateShieldedVmConfigif you plan to create a Shielded VM instance and you want to be able to change any of the Shielded VM settings compute.networks.useon the project if using a legacy network compute.subnetworks.useeither on the whole project or on the chosen subnet (VPC networks) compute.networks.useExternalIpon the project if you need to assign an external IP address (either ephemeral or static) to the instance using a legacy network compute.subnetworks.useExternalIpeither on the whole project or on the chosen subnet if you need to assign an external IP address (either ephemeral or static) to the instance using a VPC network compute.addresses.useon the project if specifying a static address in the project compute.instances.setMetadataif setting metadata compute.instances.setTagson the instance if setting tags compute.instances.setLabelson the instance if setting labels compute.instances.setServiceAccounton the instance if setting service account compute.images.useReadOnlyon the image if creating a new root persistent disk compute.disks.createon the project if creating a new root persistent disk with this instance compute.disks.useReadOnlyon the disk if attaching an existing persistent disk in read-only mode compute.disks.useon the disk if attaching an existing disk in read/write mode compute.disks.setLabelson the disk if setting labels compute.snapshots.createon the project to create a new snapshot if creating an instance from a snapshot compute.snapshots.useReadOnlyon the snapshot if creating an instance from a snapshot compute.instanceTemplates.useReadOnlyon the instance template if creating instance from instance template Console When restoring non-boot snapshots to a new VM from the console, first create a disk from each snapshot. Then, attach the new disks when you create the VM. Restore each non-boot snapshot to a new disk. In the Google Cloud console, go to the Disks page. Click Create disk. Specify a Name for your disk. For more information, see Resource naming convention. Select the Region and Zone for this disk. The disk and VM must be in the same zone for zonal disks, or region for regional disks. Select a disk Type. Under Source type, select Snapshot. Under the new Source snapshot field, select a non-boot snapshot that you want to restore to the new disk. To create the disk, click Create. Repeat these steps to create a disk from each snapshot that you want to restore. When creating a VM, you can add up to 15 non-boot disks. - In the Google Cloud console, go to the VM instances page. Select your project and click Continue. Click Create instance. - Specify a Name for your VM. For more information, see Resource naming convention. - Select the Region and Zone for this VM. The disk and VM must be in the same zone for zonal disks, or region for regional disks. - Select a Machine type for your VM. - If you want to allow incoming external traffic, change the Firewall rules for the VM. To attach disks to the VM, expand the Advanced options section, and then do the following: - Expand the Disks section. - Click Attach existing disk. - In the Disk list, select a disk to attach to this VM. - In the Attachment Setting section, select disk's attachment Mode and the Deletion rule. For more information about adding new disks, see Add a persistent disk to your VM. - Click Save. Repeat these steps for each disk that you want to attach. When creating a VM, you can add up to 15 non-boot disks. To create and start the VM, click Create. gcloud Create a VM by using the gcloud compute instances create command. For each non-boot snapshot that you want to restore, include the --create-disk flag, and specify a source-snapshot. When creating a VM, you can add up to 15 non-boot disks. For example, to restore two non-boot snapshots to a new VM, use the following command: gcloud compute instances create VM_NAME \ --create-disk source-snapshot=SNAPSHOT_1_NAME,name=DISK_1_NAME,size=DISK_1_SIZE,type=DISK_1_TYPE \ --create-disk source-snapshot=SNAPSHOT_2_NAME,name=DISK_2_NAME,size=DISK_2_SIZE,type=DISK_2_TYPE Replace the following: VM_NAME: name for the new VM SNAPSHOT_1_NAMEand SNAPSHOT_2_NAME: names of non-boot snapshots that you want to restore DISK_1_NAMEand DISK_2_NAME: names of the new non-boot disks for this VM DISK_1_SIZEand DISK_2_SIZE: Optional: sizes, in gigabytes, of each new non-boot disk The sizes must be equal to or larger than the sizes of the source disks from which the snapshot was made. DISK_1_TYPEand DISK_2_TYPE: Optional: types of the persistent disks For example, https://www.googleapis.com/compute/v1/projects/PROJECT_ID/zones/ZONE/diskTypes/pd-ssd. REST When using the API to restore a non-boot snapshot to a new VM, the following restrictions apply: - Only one persistent disk can be the boot persistent disk. - You must attach the boot persistent disk as the first disk for that VM. - If you specify the sourceproperty, you can't also specify the initializeParamsproperty. Providing a sourceindicates that the boot persistent disk exists already, but the initializeParamsproperty indicates that Compute Engine should create a new boot persistent disk. Using the beta API, specify the sourceSnapshot field under the initializeParams property. You can add up to 15 non-boot disks by repeating the initializeParams property for every non-boot disk that you want to create. You can optionally specify the diskSizeGb and diskType properties for any of the disks that you create. For example, to restore two non-boot snapshots to a new VM, make the following request: POST https://compute.googleapis.com/compute/v1/projects/PROJECT_ID/zones/ZONE/instances { "name": "VM_NAME", "machineType": "machineTypes/MACHINE_TYPE" "networkInterfaces": [{ "accessConfigs": [{ "type": "ONE_TO_ONE_NAT", "name": "External NAT" }], "network": "global/networks/default" }], "disks": [{ "autoDelete": "true", "boot": "true", "type": "PERSISTENT", "diskSizeGb": "DISK_SIZE", "diskType": "DISK_TYPE" }, { "initializeParams": { "sourceSnapshot": "global/snapshots/SNAPSHOT_1_NAME", "diskSizeGb": "DISK_SIZE", "diskType": "DISK_TYPE" } }, { "initializeParams": { "sourceSnapshot": "global/snapshots/SNAPSHOT_2_NAME", "diskSizeGb": "DISK_SIZE", "diskType": "DISK_TYPE" } }] } Replace the following: PROJECT_ID: your project ID ZONE: zone where you want to create the VM VM_NAME: name of the VM that you want to restore a snapshot to MACHINE_TYPE: machine type of the VM DISK_SIZE: Optional: size, in gigabytes, of the corresponding disk When provided, this property must be equal to or larger than the size of the source disk from which the snapshot was made. DISK_TYPE: Optional: full or partial URL for the type of the corresponding persistent disk For example, https://www.googleapis.com/compute/v1/projects/PROJECT_ID/zones/ZONE/diskTypes/pd-ssd. SNAPSHOT_1_NAMEand SNAPSHOT_2_NAME: names of non-boot snapshots that you want to restore to new, non-boot disks on the new VM